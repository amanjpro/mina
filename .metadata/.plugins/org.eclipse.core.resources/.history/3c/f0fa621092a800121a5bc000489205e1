package ch.usi.inf.l3.mina.eval

import scala.tools.nsc.Global
import scala.tools.nsc.ast.TreeDSL
import scala.tools.nsc.plugins.Plugin
import scala.tools.nsc.plugins.PluginComponent
import scala.tools.nsc.transform.Transform
import scala.tools.nsc.transform.TypingTransformers
import ch.usi.inf.l3.mina._
import store._

class HPE(val global: Global) extends Plugin {
  import global._

  val name = "mina"
  val description = """|This is a partial evaluator plugin based on Hybrid 
    |Partial Evaluation by W. Cook and A. Shali 
    |http://www.cs.utexas.edu/~wcook/Civet/"""

  val components = List[PluginComponent](HPEComponent)

  private object HPEComponent extends PluginComponent
    with Transform
    with TypingTransformers
    with TreeDSL {

    val global: HPE.this.global.type = HPE.this.global
    val runsAfter = List[String]("parser")
    override val runsBefore = List[String]("namer")
    val phaseName = HPE.this.name

    def newTransformer(unit: CompilationUnit) = new HPETransformer(unit)

    class HPETransformer(unit: CompilationUnit)
      extends TypingTransformer(unit) {
      import CODE._
      private val fevalError: String = """|Blocks marked as CT shall be 
        						|completely known at compilation time."""

      override def transform(tree: Tree): Tree = {
        var newTree: Tree = tree match {
          case cd @ ClassDef(mods, className, tparams, impl) => //if(cd.symbol.isClass)=>
            val newBody = impl.body.flatMap(_ match {
              case vd @ ValDef(mod, name, tpt, rhs) =>
                val scalaTypeName = newTermName("scala")
                val scalaIdent = Ident(scalaTypeName)
                val predefTermName = newTermName("Predef")
                val predefSelect = Select(scalaIdent, predefTermName)
                val printlnSelect = Select(predefSelect, newTermName("println"))
                val applyPrint = Apply(printlnSelect, List(Literal(Constant("Hello"))))
                List(applyPrint, vd) // :: Nil
              case x => List(x) // :: Nil
            })
            treeCopy.ClassDef(tree, mods, className, tparams, treeCopy.Template(
              impl, impl.parents, impl.self, newBody))
          case _ => tree
        }
        super.transform(newTree)
      }

      private def feval(tree: Tree, env: Environment): (Value, Environment) = {
        tree match {
          case v: Literal => (AbsValue(HPELiteral(v)), env)
          case v: ValDef => (env.getValue(v).get, env)
          case Assign(lhs, rhs) =>
            val (rhs1, env1) = feval(rhs, env)
            val env2 = env.addValue(lhs, rhs1)
            (rhs1, env2)
          //TODO what about binary operations?
          //FIXME How should I support sequences?
          case If(cond, thenp, elsep) =>
            val (cond1, env1) = feval(cond, env)
            val x = cond1.value.get
            if (x == Literal(Constant(true)))
              feval(thenp, env1)
            else if (x == Literal(Constant(false)))
              feval(elsep, env1)
            else
              fail(fevalError)
//          LabelDef( // def while$1(): Unit, tree.tpe=Unit
//          ()
//          If( // tree.tpe=Unit
//            true
//            Block( // tree.tpe=Unit
//              Apply( // def +(x: Int): Int in class Int, tree.tpe=Int
//                "x"."$plus" // def +(x: Int): Int in class Int, tree.tpe=(x: Int)Int
//                "y" // y: Int, tree.tpe=Int
//              )
//              Apply( // def while$1(): Unit, tree.tpe=Unit
//                "while$1" // def while$1(): Unit, tree.tpe=()Unit
//                Nil
//              )
//            )
//            ()
//          )
          //TODO for while loop you should be able to generate If tree
        }
      }

      private def fail(msg: String): (Value, Environment) = {
        throw new HPEException(msg)
      }

    }

  }
}
