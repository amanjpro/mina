/*
 * Copyright (c) <2013>, Amanj Sherwany <http://www.amanj.me>
 * All rights reserved.
 * */

package scala.ch.usi.inf.l3.mina.eval

import scala.tools.nsc.Global._
import scala.tools.nsc.ast.TreeDSL
import scala.tools.nsc.plugins.Plugin
import scala.tools.nsc.plugins.PluginComponent
import scala.tools.nsc.transform.Transform
import scala.tools.nsc.transform.TypingTransformers
import scala.tools.nsc.CompilationUnits


class HPETransformer(unit: CompilationUnit)
  extends TypingTransformer(unit) {
  import CODE._

  override def transform(tree: Tree): Tree = {
    var newTree: Tree = tree match {
      case cd @ ClassDef(mods, className, tparams, impl) => //if(cd.symbol.isClass)=>
        val newBody = impl.body.flatMap(_ match {
          case vd @ ValDef(mod, name, tpt, rhs) =>
            val scalaTypeName = newTermName("scala")
            val scalaIdent = Ident(scalaTypeName)
            val predefTermName = newTermName("Predef")
            val predefSelect = Select(scalaIdent, predefTermName)
            val printlnSelect = Select(predefSelect, newTermName("println"))
            val applyPrint = Apply(printlnSelect, List(Literal(Constant("Hello"))))
            List(applyPrint, vd) // :: Nil
          case x => List(x) // :: Nil
        })
        treeCopy.ClassDef(tree, mods, className, tparams, treeCopy.Template(
          impl, impl.parents, impl.self, newBody))
      case _ => tree
    }
    super.transform(newTree)
  }

}